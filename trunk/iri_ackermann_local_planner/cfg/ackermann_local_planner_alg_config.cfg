#! /usr/bin/env python
#*  All rights reserved.
#*
#*  Redistribution and use in source and binary forms, with or without
#*  modification, are permitted provided that the following conditions
#*  are met:
#*
#*   * Redistributions of source code must retain the above copyright
#*     notice, this list of conditions and the following disclaimer.
#*   * Redistributions in binary form must reproduce the above
#*     copyright notice, this list of conditions and the following
#*     disclaimer in the documentation and/or other materials provided
#*     with the distribution.
#*   * Neither the name of the Willow Garage nor the names of its
#*     contributors may be used to endorse or promote products derived
#*     from this software without specific prior written permission.
#*
#*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#*  POSSIBILITY OF SUCH DAMAGE.
#***********************************************************

# Author: 

PACKAGE='iri_ackermann_local_planner'
import roslib; roslib.load_manifest(PACKAGE)

import sys
from math import pi

from dynamic_reconfigure.parameter_generator import *

gen = ParameterGenerator()

#       Name                       Type       Reconfiguration level            Description                       Default   Min   Max
gen.add("ack_vel_max",             double_t,  0,                               "maximum translational speed",    0.3,      0,    20)
gen.add("ack_vel_min",             double_t,  0,                               "minimum translational speed",    -0.3,     -20,  0)
gen.add("ack_acc_max",             double_t,  0,                               "maximum translational acceleration", 1.0,  0,    20)
gen.add("ack_steer_angle_max",     double_t,  0,                               "maximum steer angle",            0.35,     0,    0.4)
gen.add("ack_steer_angle_min",     double_t,  0,                               "minimum steer angle",            -0.35,    -0.4, 0)
gen.add("ack_steer_speed_max",     double_t,  0,                               "maximum steer speed",            0.5,      0,    2)
gen.add("ack_steer_speed_min",     double_t,  0,                               "minimum steer speed",            -0.5,     -2,   0)
gen.add("ack_steer_acc_max",       double_t,  0,                               "maximum steer acceleration",     1,        0,    5)
gen.add("ack_axis_distance",       double_t,  0,                               "distance between axes",          1.65,     0,    2)

gen.add("sim_time",                double_t,  0,                               "The amount of time to roll trajectories out for in seconds", 10, 0, 10)
gen.add("sim_granularity",         double_t,  0,                               "The granularity with which to check for collisions along each trajectory in meters", 0.025, 0, 5)

gen.add("pdist_scale",             double_t,  0,                               "The weight for the path distance part of the cost function", 0.6, 0, 5)
gen.add("gdist_scale",             double_t,  0,                               "The weight for the goal distance part of the cost function", 0.8, 0, 5)
gen.add("occdist_scale",           double_t,  0,                               "The weight for the obstacle distance part of the cost function", 0.01,0, 5)
gen.add("hdiff_scale",             double_t,  0,                               "The weight for the heading distance part of the cost function", 1.0 ,0, 5)
gen.add("heading_points",          int_t,     0,                               "The number of points to check the heading", 8, 1, 64)

gen.add("vx_samples",              int_t,     0,                               "The number of samples to use when exploring the x velocity space", 20, 1, 300)
gen.add("vtheta_samples",          int_t,     0,                               "The number of samples to use when exploring the theta velocity space", 20, 1, 300)

gen.add("simple_attractor",        bool_t,    0,                               "Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation", False)

gen.add("angular_sim_granularity", double_t,  0,                               "The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things", 0.025, 0, pi/2)

gen.add("xy_goal_tolerance",       double_t,  0,                               "Minimum distance to end the current goal", 0.5, 0, 1)
gen.add("heading_goal_tolerance",  double_t,  0,                               "Minimum angle to end the current goal", 0.1, 0, pi/2)

gen.add("restore_defaults",        bool_t,    0,                               "Retore to the default configuration", False)

exit(gen.generate(PACKAGE, "AckermannLocalPlannerAlgorithm", "AckermannLocalPlanner"))
